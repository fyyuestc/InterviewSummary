[TOC]

# <font color=red>红黑树总结</font>

## 1. 二叉查找树

### 1.1 删除某节点

假设要删除的为节点 p，则对于二叉查找树来说，需要根据节点 p 所在不同的位置作不同的操作，有以下 3 种可能

1. 节点 p 为叶子节点，此时只需要删除该节点，并修改其双亲节点的指针即可；

2. 节点 p 只有左子树或者只有右子树，此时只需要将其左子树或者右子树直接变为节点 p 双亲节点的左子树即可；

3. 节点 p 左右子树都有，此时有两种处理方式：

   1）令节点 p 的左子树为其双亲节点的左子树；节点 p 的右子树为其自身直接前驱节点的右子树，如图1所示

   ![图1](https://raw.githubusercontent.com/fyyuestc/Images/main/img/202204011124009.png)

   <p align='center'>图1</p>

   2)  用节点 p 的直接前驱（或直接后继）来代替节点 p，同时在二叉查找树中对其直接前驱（或直接后继）做删除操作。如图2为使用直接前驱代替节点 p

   ![图2](https://raw.githubusercontent.com/fyyuestc/Images/main/img/202204031339227.png)

   <p align='center'>图2</p>

## 2. 红黑树

红黑树本身就是一颗**二叉查找树**，树中没有一条路径比其他任何路径长出两倍，接近平衡状态。

![红黑树](https://raw.githubusercontent.com/fyyuestc/Images/main/img/202204031339243.png)

- 每个节点是黑色或者红色
- 根节点是黑色
- 所有nil叶子节点为黑色
- 红色节点的两个孩子节点均为黑色 
- 对于任一节点而言，其到叶节点树尾端nil指针的每一条路径都包含相同数目的黑节点
- 一颗含有n个节点的红黑树的高度至多为2log(n+1)

- 节点的黑高度：从该节点到其子孙节点路径中包含的黑节点数
- 红黑树是相对接近平衡的二叉树，在二叉查找树的基础上增加了自动维持平衡的性质，插入、搜索、删除的效率都比较高

> 正是因为上述性质，使得一颗n个节点的红黑树始终保持logn的高度

### 2.1 红黑树的旋转

当使用红黑树进行插入或者删除节点的操作时，可能会破坏红黑树的 5 条性质，从而变成了一棵普通树，此时就可以通过对树中的某些子树进行旋转，从而使整棵树重新变为一棵红黑树。

旋转操作分为左旋和右旋，同二叉排序树转平衡二叉树的旋转原理完全相同。例如图3表示的是对一棵二叉查找树中局部子树进行左旋和右旋操作：

![图3](https://raw.githubusercontent.com/fyyuestc/Images/main/img/202204031350020.png)

<p align='center'>图3</p>

**左旋**：如图3所示，左旋时 y 节点变为该部分子树的根节点，同时 x 节点（连同其左子树 a）移动至 y 节点的左孩子。若 y 节点有左孩子 b，由于 x 节点需占用其位置，所以调整至 x 节点的右孩子处。

**右旋**：如图3所示，同左旋是同样的道理，x 节点变为根节点，同时 y 节点连同其右子树 c 作为 x 节点的右子树，原 x 节点的右子树 b 变为 y 节点的左子树。



### 2.2 红黑树的插入新节点

当创建一个红黑树或者向已有红黑树中插入新的数据时，只需要按部就班地执行以下 3 步：

- 由于红黑树本身是一棵二叉查找树，所以在插入新的节点时，完全按照二叉查找树插入节点的方法，找到新节点插入的位置；
- 将新插入的节点节点初始化，颜色设置为红色后插入到指定位置；（将新节点初始化为红色插入后，不会破坏红黑树第 5 条的性质）
- 由于插入新的节点，可能会破坏红黑树第 4 条的性质（若其父节点颜色为红色，就破坏了红黑树的性质），此时需要调整二叉查找树，想办法通过旋转以及修改树中节点的颜色，使其重新成为红黑树！

---

插入节点的第 1 步和第 2 步都非常简单，关键在于最后一步对树的调整！在红黑树中插入节点时，根据插入位置的不同可分为以下 3 种情况：

1. 插入位置为整棵树的树根。处理办法：只需要将插入节点的颜色改为黑色即可。

2. 插入位置的双亲节点的颜色为黑色。处理方法：此种情况不需要做任何工作，新插入的颜色为红色的节点不会破坏红黑树的性质。

3. 插入位置的双亲节点的颜色为红色。处理方法：由于插入节点颜色为红色，其双亲节点也为红色，破坏了红黑树第 4 条性质，此时需要结合其祖父节点和祖父节点的另一个孩子节点（父节点的兄弟节点，此处称为“叔叔节点”）的状态，分为 3 种情况讨论:

   * 当前节点的父节点是红色，且“叔叔节点”也是红色：破坏了红黑树的第 4 条性质，解决方案为：将父节点颜色改为黑色；将叔叔节点颜色改为黑色；将祖父节点颜色改为红色；下一步将祖父节点认做当前节点，继续判断，处理结果如下图所示：

     ![](https://raw.githubusercontent.com/fyyuestc/Images/main/img/202204031350203.png)

   **分析**：此种情况下，由于父节点和当前节点颜色都是红色，所以为了不产生冲突，将父节点的颜色改为黑色。但是虽避免了破坏第 4 条，但是却导致该条路径上的黑高度增加了 1 ，破坏了第 5 条性质。但是在将祖父节点颜色改为红色、叔叔节点颜色改为黑色后，该部分子树没有破坏第 5 条性质。但是由于将祖父节点的颜色改变，还需判断是否破坏了上层树的结构，所以需要将祖父节点看做当前节点，继续判断。

   * 当前节点的父节点颜色为红色，叔叔节点颜色为黑色，且当前节点是父节点的右孩子。解决方案：将父节点作为当前节点做左旋操作。

     ![](https://raw.githubusercontent.com/fyyuestc/Images/main/img/202204031356676.png)

   **分析**：在进行以父节点为当前节点的左旋操作后，此种情况就转变成了第 3 种情况，处理过程跟第 3 种情况同步进行。

   * 当前节点的父节点颜色为红色，叔叔节点颜色为黑色，且当前节点是父节点的左孩子。解决方案：将父节点颜色改为黑色，祖父节点颜色改为红色，从祖父节点处进行右旋处理。如下图所示：

     ![](https://raw.githubusercontent.com/fyyuestc/Images/main/img/202204031356010.png)

   **分析**：在此种情况下，由于当前节点 F 和父节点 S 颜色都为红色，违背了红黑树的性质 4，此时可以将 S 颜色改为黑色，有违反了性质 5，因为所有 通过 S 的路径其黑高度都增加了 1 ，所以需要将其祖父节点颜色设为红色后紧接一个右旋，这样这部分子树有成为了红黑树。（上图中的右图虽看似不是红黑树，但是只是整棵树的一部分，以 S 为根节点的子树一定是一棵红黑树）



### 2.3 红黑树删除节点

在二叉查找树删除节点时，分为 3 种情况：

- 若该删除节点本身是叶子节点，则可以直接删除；

- 若只有一个孩子节点（左孩子或者右孩子），则直接让其孩子节点顶替该删除节点；

- 若有两个孩子节点，则找到该节点的右子树中值最小的叶子节点来顶替该节点，然后删除这个值最小的叶子节点。

  

在红黑树中删除节点，思路更简单，只需要完成 2 步操作：

1. 将红黑树按照二叉查找树删除节点的方法删除指定节点；

2. 重新调整删除节点后的树，使之重新成为红黑树；（还是通过旋转和重新着色的方式进行调整）

   

以上情况最终都需要删除某个节点，此时需要判断删除该节点是否会破坏红黑树的性质。判断的依据是：

1. 如果删除节点的颜色为红色，则不会破坏；
2. 如果删除节点的颜色为黑色，则肯定会破坏红黑树的第 5 条性质，此时就需要对树进行调整，调整方案分 4 种情况讨论：

- 删除节点的兄弟节点颜色是红色，调整措施为：将兄弟节点颜色改为黑色，父亲节点改为红色，以父亲节点来进行左旋操作，同时更新删除节点的兄弟节点（左旋后兄弟节点发生了变化），如下图所示：
  

![](https://raw.githubusercontent.com/fyyuestc/Images/main/img/202204031356849.png)

- 删除节点的兄弟节点及其孩子全部都是黑色的，调整措施为：将删除节点的兄弟节点设为红色，同时设置删除节点的父节点标记为新的节点，继续判断；
- 删除节点的兄弟节点是黑色，其左孩子是红色，右孩子是黑色。调整措施为：将兄弟节点设为红色，兄弟节点的左孩子节点设为黑色，以兄弟节点为准进行右旋操作，最终更新删除节点的兄弟节点；
- 删除节点的兄弟节点是黑色，其右孩子是红色（左孩子不管是什么颜色），调整措施为：将删除节点的父节点的颜色赋值给其兄弟节点，然后再设置父节点颜色为黑色，兄弟节点的右孩子节点为黑色，根据其父节点做左旋操作，最后设置替换删除节点的节点为根节点；

## 3. 红黑树的应用

红黑树的应用比较广泛，主要是用它来存储有序的数据，它的时间复杂度是O(logn)，效率非常之高。
例如，Java集合中的TreeSet和TreeMap，C++ STL中的set、map，以及Linux虚拟内存的管理，都是通过红黑树去实现的，而 JDK8 中 HashMap 当链表长度大于 8 时也会转化为红黑树

## 4. 总结

> 红黑树，虽隶属于二叉查找树，但是二叉查找树的时间复杂度会受到其树深度的影响，而红黑树可以保证在最坏情况下的时间复杂度仍为`O(lgn)`。当数据量多到一定程度时，使用红黑树比二叉查找树的效率要高。
>
> 同平衡二叉树相比较，红黑树没有像平衡二叉树对平衡性要求的那么苛刻，虽然两者的时间复杂度相同，但是红黑树在实际测算中的速度要更胜一筹！平衡二叉树的时间复杂度是`O(logn)`，红黑树的时间复杂度为`O(lgn)`，两者都表示的都是时间复杂度为对数关系（lg 函数为底是 10 的对数，用于表示时间复杂度时可以忽略）。







