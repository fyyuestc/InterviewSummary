

[TOC]

# 一. 文件描述符概念

> 文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。Linux 系统中，把一切都看做是文件，当进程打开现有文件或创建新文件时，内核向进程返回一个文件描述符，文件描述符就是内核为了高效管理已被打开的文件所创建的索引，用来指向被打开的文件，所有执行I/O操作的系统调用都会通过文件描述符

<br>

**关于文件描述符，Linux内核维护了3个数据结构**

* 进程级的文件描述符表

* 系统级的打开文件描述符表

* 文件系统的i-node表

<div align="center">    
<img src="https://segmentfault.com/img/bVOX3l?w=619&h=312"/>
</div>



<div align="center">    
<img src="https://imgconvert.csdnimg.cn/aHR0cDovL2MuYmlhbmNoZW5nLm5ldC91cGxvYWRzL2FsbGltZy8xOTA0MTAvMS0xWjQxMDFINDVTMTMuZ2lm"/>
</div>




* 在进程 A 中，文件描述符 1 和 20 都指向了同一个打开文件表项，标号为 23（指向了打开文件表中下标为 23 的数组元素），这可能是通过调用 dup()、dup2()、fcntl() 或者对同一个文件多次调用了 open() 函数形成的
* 进程 A 的文件描述符 2 和进程 B 的文件描述符 2 都指向了同一个文件，这可能是在调用 fork() 后出现的（即进程 A、B 是父子进程关系），或者是不同的进程独自去调用 open() 函数打开了同一个文件，此时进程内部的描述符正好分配到与其他进程打开该文件的描述符一样(概率很低)
* 进程 A 的描述符 0 和进程 B 的描述符 3 分别指向不同的打开文件表项，但这些表项均指向 i-node 表的同一个条目（标号为 1976）；换言之，它们指向了同一个文件。发生这种情况是因为每个进程各自对同一个文件发起了 open() 调用。同一个进程两次打开同一个文件，也会发生类似情况

---

# 二. Linux文件和目录

Linux文件是树形结构，inode是平坦结构，通过inode->i_mode字段，即S_ISREG、S_ISDIR两个宏判断是哪个类型。

* 普通文件：**inode**里面存储元数据，inode索引到block，block存储数据

* 目录文件：inode索引到block，block中存储许多dirent目录条目，即名字到inode number的映射表

  <div align="center">    
  <img src="https://mmbiz.qpic.cn/mmbiz_png/4UtmXsuLoNdiccaOa8HrBYevRaP1PxbA0sq6o0hBm92yFicAX2y3Tia5nvfSjOQ6HicV8xRczwSsBBkUY1gZOvE88g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" width = 500 height = 300 />
  </div>

目录文件的block区域如下：

<div align="center">    
<img src="https://mmbiz.qpic.cn/mmbiz_png/4UtmXsuLoNdiccaOa8HrBYevRaP1PxbA0VggkG4rAxt7Rom7p9fvwy0Iht406k1AtibicC75CGp5NeRuxvKF6xzqA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" height = 500 />
</div>

内存的树形结构：

* dentry 绑定到唯一一个 inode 结构体；
* dentry 有父，子，兄弟的索引路径，有这个就足够在内存中构建一个树了，并且事实也确实如此；

```c
struct dentry {
   // ...
   struct dentry  *d_parent;   /* 父节点 */
   struct qstr     d_name;      // 名字
   struct inode   *d_inode;    // inode 结构体

   struct list_head d_child;     /* 兄弟节点 */
   struct list_head d_subdirs;   /* 子节点 */ 
};
```

------

# 三. ln命令

* 软链接：软链接文件是一个全新的文件，有独立的 inode，有自己的 block ，内容是一段 path 路径，这个路径直接指向源文件；

  <div align="center">    
  <img src="https://mmbiz.qpic.cn/mmbiz_png/4UtmXsuLoNdiccaOa8HrBYevRaP1PxbA0iaI3yL5GPG9DqiaPJ80mVxJoSesfv7XJPib7ibhPRwPO3JiaaqUZZZsickBw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" width = 500 height = 300 />
  </div>

* 硬链接：

  >硬链接文件其实并没有新建文件（也就是说，没有消耗 inode 和 文件所需的 block 块）；
  >
  >硬链接其实是修改了当前目录所在的目录文件，加了一个 dirent 而已，这个 dirent 用一个新的 name 名字指向原来的 inode number；
  >
  >由于新旧两个 dirent 都是指向同一个 inode，那么就导致了一个限制：**不能跨文件系统。因为，不同文件系统的 inode 管理都是独立的。**

<div align="center">    
<img src="https://mmbiz.qpic.cn/mmbiz_png/4UtmXsuLoNdiccaOa8HrBYevRaP1PxbA0N8hYhDUxKchFtnwDjNRepR5nSsA4vyLxwxr7jG8abvCAYGR8qXbD6Q/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" height="500"/>
</div>

总结：**硬链接只增加了一个 dirent 项，只修改了目录文件而已。不涉及到 inode 数量的变化。新的 name 指向原来的 inode。**

---

# 四. mv命令

* 源文件和目标文件在同一文件系统下：

> mv 命令的核心操作是系统调用 rename ，rename 从内核实现来说只涉及到元数据的操作，只涉及到 dirent 的增删；
>
> **inode number 不变，inode 不变，不增不减，还是原来的 inode 结构体，所以数据完全没有拷贝。**

<br>

* 源文件和目标文件不在同一文件系统下：

>  系统调用 rename 的时候，如果**源**和**目的**不在同一文件系统时，会报告 EXDEV 的错误码，提示该调用不能跨文件系统。

**这个时候操作分成两步走，先 copy ，后 remove：**

1.  走不了 rename ，那么就退化成 copy ，也就是真正的拷贝。读取源文件，写入目标位置，生成一个全新的目标文件副本；

   > 这里调用的 copy_reg 的函数封装；
   >
   > ln，mv，cp 是在 coreutils 库里的命令，公用函数本身就是可以复用的；

2. 删除源文件，使用 rm 函数删除；

---

# 五. cp命令

[深度剖析 Linux cp 的秘密-博客](https://juejin.cn/post/6939328247922425869)



# 六. 总结

1. 目录文件是一种特殊的文件，可以理解成存储的是 dirent 列表。dirent 只是名字到 inode 的映射，这个是树形结构的基础；
2. 常说目录树在内存中确实是一个树的结构，每个节点由 dentry 结构体表示；
3. ln -s 创建软链接文件，软链接文件是一个独立的新文件，有一个新的 inode ，有新的 dentry，文件类型为 link，文件内容就是**一条指向源的路径**，所以**软链的创建可以无视文件系统，跨越山河；**
4. ln 默认创建硬连接，硬链接文件只在目录文件里添加了一个新 dirent 项 (新name:原inode)，文件 inode 还是和原文件同一个，**所以硬链接不能跨文件系统（因为不同的文件系统是独立的一套 inode 管理方式，不同的文件系统实例对 inode number 的解释各有不同）；**
5. ln 命令貌似创建出了新文件，但其实不然，ln 只跟元数据相关，涉及到 dirent  的变动，**不涉及到数据的拷贝**，起不到数据备份的目的；
6. mv 其实是调用 rename 调用，**在同一个文件系统中不涉及到数据拷贝，只涉及到元数据变更**（ dirent 的增删 ），所以速度也很快。但如果 mv 的源和目的**在不同的文件系统，那么就会退化成真正的 copy ，会涉及到数据拷贝**，这个时候速度相对慢一些，慢成什么样子？就跟 cp 命令一样；
7. cp 命令才是真正的数据拷贝命令，速度可能相对慢一些，但是 cp 命令有 --spare 可以优化拷贝速度，针对空洞和全 0 数据，可以跳过，从而**针对稀疏文件可以节省大量磁盘 IO**；



















