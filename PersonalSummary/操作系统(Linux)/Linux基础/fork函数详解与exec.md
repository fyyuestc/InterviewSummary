[TOC]

# 1. fork()函数后子进程复制了父进程什么

* fork之后，exec之前：

  > 两个进程用的是相同的物理空间（内存区），子进程的代码段、数据段、堆栈都是指向父进程的物理空间，也就是说，**两者的虚拟空间不同，但其对应的物理空间是同一个。采用了 copy-on-write 技术，当父子进程中有更改相应段的行为发生时，再为子进程相应的段分配物理空间**。

* 因为exec进程替换时执行代码不同：

  > exec只是用一个全新的程序替换了当前进程的代码段，数据，堆和栈段。因此，数据段、堆栈段分配单独的物理空间、子进程的代码段也会分配单独的物理空间，所以也就为什么不是直接在内存上给子进程也复制完完全全相同的区域

* 过程总结：

  ​        fork子进程完全复制父进程的虚拟地址空间，也复制了页表，**但没有复制物理页面**，所以这时虚拟地址相同，物理地址也相同，但是会把父子共享的页面标记为“只读”（**类似mmp的private的方式**），直到其中任何一个进程要对共享的页面“**写操作**”，这时内核会复制一个物理页面给这个进程使用，同时修改页表，而把原来的只读页面标记为“可写”，留给另外一个进程使用。

  ​        简洁来说就是：内核只为新生成的子进程创建虚拟空间，它们复制于父进程的虚拟空间，但是不为这些段分配物理空间，它们共享父进程的物理空间，当父子进程中有写内存的行为发生时，再为子进程相应的段分配物理空间（复制更改的变量所在的一页），这就是写时拷贝技术

  <div align="center">    
    <img src="https://img-blog.csdn.net/20180810204440411?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0V1bmljZV9mYW4xMjA3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" />
    </div>

> 正因为fork采用了这种写时拷贝的机制，所以fork出来子进程之后，父子进程哪个先调度呢？内核一般会先调度子进程，因为很多情况下子进程是要马上执行exec，这时会清空栈、堆这些和父进程共享的空间，加载新的代码段。这就避免了“写时拷贝”共享页面的机会。如果父进程先调度很可能写共享页面，会产生“写时拷贝”的无用功。所以，一般是子进程先调度。

