[TOC]

# 一. 库与可执行文件

链接器可以操作的最小单元为**目标文件**，也就是说我们见到的无论是**静态库、动态库、可执行文件**，都是基于目标文件构建出来的。

<div align="center">
	<img src="https://segmentfault.com/img/bVbg264?w=297&h=249" />
</div>

---

# 二. 静态库

## 2.1 简介

* 静态库在Windows下是以.lib为后缀的文件，Linux下是以.a为后缀的文件

* 可以简单的将静态库理解为由一堆目标文件打包而成， 使用者只需要使用其中的函数而无需关注该函数来自哪个目标文件
* 找到函数实现所在的目标文件是链接器来完成的，从这里也可以看出，不是所有静态库中的目标文件都会用到，而是用到哪个链接器就链接哪个

## 2.2 静态链接

* 静态库是链接器通过**静态链接**将其和**其它目标文件**合并生成可执行文件的，如下图所示，而静态库只不过是将**多个目标文件**进行了打包，在链接时只取静态库中所用到的目标文件
* 静态链接生成的可执行文件在运行时不依赖任何其它代码

<div align="center">
	<img src="https://segmentfault.com/img/bVbg27a?w=311&h=248" />
</div>

<div align="center">
	<img src="https://segmentfault.com/img/bVbg27g?w=485&h=364" />
</div>



---

## 2.2 静态链接下可执行文件的生成

目标文件被分成了三段，代码段，数据段，符号表。链接器将使用到的目标文件集合进行拼装，拼装之后就生成了可执行文件。

<div align="center">
	<img src="https://segmentfault.com/img/bVbg4Uu?w=291&h=467" />
</div>

> 可执行文件区别于目标文件的地方在于，可执行文件有一个入口函数，这个函数也就是我们在C语言当中定义的main函数，main函数在执行过程中会用到所有可执行文件当中的代码和数据。操作系统(Operating System)调用执行main函数

# 三. 动态库

## 3.1 简介

* 在Linux下动态库是以**.so**为后缀的文件，同时以lib为前缀，比如进行数字计算的动态库**Math**，编译链接后产生的动态库就叫做**libMath.so**。动态库也是库，本质上动态库同样包含我们已经熟悉的代码段、数据段、符号表。只不过动态库的使用方式以及使用时间和静态库不太一样
* 动态库允许使用该库的可执行文件仅仅包含对动态库的**引用**而无需将该库**拷贝**到可执行文件当中。也就是说，同静态库进行整体拷贝的方式不同，对于动态库的使用仅仅需要可执行文件当中包含必要的信息
* helloworld程序中的printf函数是在**libc.so**当中定义的，Linux下编译链接生成可执行文件时会默认动态链接libc.so(Windows下也是同样的道理)，使用**ldd命令**就会发现每个可执行文件都依赖libc.so

<div align="center">
	<img src="https://segmentfault.com/img/bVbg4TD?w=393&h=258" />
</div>

## 3.2 动态链接

### 3.2.1 加载时动态链接

* 程序的加载就是把**可执行文件从磁盘搬到内存**的过程，因为程序最终都是在内存中被执行的，而动态链接就出现在这个加载的过程

* 当把可执行文件复制到内存后，且在程序开始运行之前，操作系统会查找可执行文件**依赖的动态库信息**(主要是动态库的名字以及存放路径)，找到该动态库后就将该**动态库从磁盘搬到内存**，并进行符号决议

> 阶段一：将动态库信息写入可执行文件
>
> gcc ... -lMath -L/user/lib---> 将libMath.so加入到链接选项当中，生成的可执行文件中保存了依赖的动态库信息
>
> 阶段二：加载可执行文件时依据动态库信息进行动态链接

### 3.2.2 运行时动态链接

>  **运行时**指的就是从程序开始被CPU执行到程序执行完成退出的这段时间，**不需要**在编译链接时提供动态库信息，只有**当程序运行到需要调用动态库所提供的代码**时才会启动动态链接过程,**加快**程序的启动速度

## 3.3 动态链接下可执行文件的生成

* 在动态链接下，链接器并不是将动态库中的代码和数据拷贝到可执行文件中，而是将**动态库的必要信息**写入了可执行文件，这样当可执行文件在加载时就可以根据此信息进行动态链接
* 静态链接中将目标文件划分为了两段，数据段和代码段，而在动态链接下，可执行文件当中会新增两段，即dynamic段以及GOT（Global offset table）段，这两段内容就是之前所说的**必要信息**。

<div align="center">
	<img src="https://segmentfault.com/img/bVbg3Mb?w=92&h=226" />
</div>



* dynamic段中保存了可执行文件依赖哪些动态库，动态链接符号表的位置以及重定位表的位置等信息

* 当加载可执行文件时，操作系统根据dynamic段中的信息即可找到使用的动态库，从而完成动态链接
* 在编译链接过程中，可以同时使用动态库以及静态库，这两种库的使用并不冲突



# 4. 动态库VS静态库

## 4.1 动态库优点

* 内存中只需要有一份libc代码，所有的程序（进程）共享这一份代码，因此极大的节省了内存资源
* 如果我们修改了动态库的代码，我们只需要重新编译动态库就可以了而**无需重新编译**我们自己的程序，因为可执行文件当中仅保留了动态库的必要信息，重新编译动态库后这些必要都信息是不会改变的（只要不修改动态库的名字和动态库导出的供可执行文件使用的函数），编译好新的动态库后只需要简单的替换原有动态库，下一次运行程序时就可以使用新的动态库了，因此动态库的这种特性极大的方便了程序升级和bug修复
* 所有的插件实现函数必须都有一个统一的格式，程序在运行时需要加载所有插件（动态库），然后调用所有插件的入口函数（统一的格式），这样我们写的插件就可以被执行起来了















